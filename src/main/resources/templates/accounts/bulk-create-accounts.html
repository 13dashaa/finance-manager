<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Bulk Create Accounts</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <style>
        .account-form-section {
            border: 1px solid #ccc;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 5px;
            position: relative; /* For positioning the remove button */
        }
        .remove-account-btn {
            position: absolute;
            top: 10px;
            right: 10px;
        }
        /* Style for field errors */
        .is-invalid {
            border-color: #dc3545;
        }
        .text-danger {
            font-size: 80%;
        }
    </style>
</head>
<body>
<div class="container mt-4">
    <h1>Create Multiple Accounts</h1>

    <!-- Success Message Display (if redirected with flash attribute) -->
    <div th:if="${successMessage}" class="alert alert-success" role="alert" th:text="${successMessage}">
        Success!
    </div>

    <!-- Form posts to the correct controller method -->
    <form th:action="@{/accounts/bulk}" th:object="${bulkCreateDto}" method="post" novalidate="novalidate"> <!-- novalidate prevents browser validation -->

        <!-- Display Global Errors (e.g., minimum items, creation error) -->
        <div th:if="${#fields.hasGlobalErrors()}" class="alert alert-danger" role="alert">
            <ul>
                <li th:each="err : ${#fields.globalErrors()}" th:text="${err}">Global Error Message</li>
            </ul>
        </div>

        <div id="account-forms-container">
            <!-- Iterate over items in the bulkCreateDto object -->
            <!-- Use th:errorclass to highlight fields with errors -->
            <div th:each="item, stat : *{items}" class="account-form-section" th:id="'account-section-' + ${stat.index}">
                <button type="button" class="btn btn-sm btn-danger remove-account-btn" onclick="removeAccountForm(this)">Remove</button>
                <h5 th:text="'Account #' + (${stat.index} + 1)">Account #</h5>

                <!-- Fields bound using items[index].fieldName -->
                <div class="form-group">
                    <label th:for="${'name' + stat.index}">Name:</label>
                    <input type="text" class="form-control" th:id="${'name' + stat.index}"
                           th:field="*{items[__${stat.index}__].name}" required
                           th:errorclass="${#fields.hasErrors('items[__${stat.index}__].name')} ? 'is-invalid' : ''">
                    <span th:if="${#fields.hasErrors('items[__${stat.index}__].name')}"
                          th:errors="*{items[__${stat.index}__].name}"
                          class="text-danger">Name Error</span>
                </div>

                <div class="form-group">
                    <label th:for="${'balance' + stat.index}">Balance:</label>
                    <!-- Use step="any" for BigDecimal/Double -->
                    <input type="number" step="any" class="form-control" th:id="${'balance' + stat.index}"
                           th:field="*{items[__${stat.index}__].balance}" required
                           th:errorclass="${#fields.hasErrors('items[__${stat.index}__].balance')} ? 'is-invalid' : ''">
                    <span th:if="${#fields.hasErrors('items[__${stat.index}__].balance')}"
                          th:errors="*{items[__${stat.index}__].balance}"
                          class="text-danger">Balance Error</span>
                </div>

                <div class="form-group">
                    <label th:for="${'clientId' + stat.index}">Client:</label>
                    <!-- Ensure ${clients} is passed from the Controller -->
                    <select class="form-control" th:id="${'clientId' + stat.index}"
                            th:field="*{items[__${stat.index}__].clientId}"
                            th:errorclass="${#fields.hasErrors('items[__${stat.index}__].clientId')} ? 'is-invalid' : ''">
                        <option value="">Select Client</option>
                        <!-- Check if clients variable exists before iterating -->
                        <th:block th:if="${clients != null}">
                            <option th:each="client : ${clients}"
                                    th:value="${client.id}"
                                    th:text="${client.username}"></option> <!-- Adjust property names if needed -->
                        </th:block>
                    </select>
                    <span th:if="${#fields.hasErrors('items[__${stat.index}__].clientId')}"
                          th:errors="*{items[__${stat.index}__].clientId}"
                          class="text-danger">Client Error</span>
                </div>
            </div> <!-- /.account-form-section -->
        </div><!-- /#account-forms-container -->

        <button type="button" id="add-account-btn" class="btn btn-success mb-3">Add Another Account</button>
        <hr>
        <button type="submit" class="btn btn-primary">Create All Accounts</button>
        <a href="/accounts" class="btn btn-secondary">Back to List</a>

    </form> <!-- End of form -->

    <!-- Template for new forms (hidden) -->
    <div id="account-form-template" style="display: none;">
        <div class="account-form-section">
            <button type="button" class="btn btn-sm btn-danger remove-account-btn" onclick="removeAccountForm(this)">Remove</button>
            <h5>Account #<span></span></h5>
            <div class="form-group">
                <label>Name:</label>
                <!-- Add name attribute matching the binding path -->
                <input type="text" class="form-control" name="items[INDEX].name" required>
                <span class="text-danger error-span" data-field-stub="name"></span>
            </div>
            <div class="form-group">
                <label>Balance:</label>
                <input type="number" step="any" class="form-control" name="items[INDEX].balance" required>
                <span class="text-danger error-span" data-field-stub="balance"></span>
            </div>
            <div class="form-group">
                <label>Client:</label>
                <select class="form-control" name="items[INDEX].clientId">
                    <option value="">Select Client</option>
                    <!-- Populate options from the main model's client list -->
                    <th:block th:if="${clients != null}">
                        <option th:each="client : ${clients}"
                                th:value="${client.id}"
                                th:text="${client.username}"></option>
                    </th:block>
                </select>
                <span class="text-danger error-span" data-field-stub="clientId"></span>
            </div>
        </div>
    </div>

</div><!-- /.container -->

<!-- JavaScript code (Your provided script is good, include it here) -->
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
<script th:inline="javascript">
    /*<![CDATA[*/

    // Get initial count from rendered forms
    let accountIndex = document.querySelectorAll('#account-forms-container .account-form-section').length;
    const container = document.getElementById('account-forms-container');
    const templateNode = document.getElementById('account-form-template'); // Get the template container
    const addBtn = document.getElementById('add-account-btn');

    // --- Function add form ---
    addBtn.addEventListener('click', function() {
        if (!templateNode) {
            console.error("Template #account-form-template not found!");
            return;
        }
        const templateContent = templateNode.firstElementChild.cloneNode(true); // Clone the actual section inside
        const newIndex = accountIndex++; // Use current index, then increment

        // Set outer div ID
        templateContent.id = 'account-section-' + newIndex;

        // Update title span
        const titleSpan = templateContent.querySelector('h5 span');
        if(titleSpan) titleSpan.textContent = (newIndex + 1);

        // Update names, IDs, fors for inputs, selects, labels, spans
        templateContent.querySelectorAll('input, select, label, span.error-span').forEach(el => {
            const nameAttr = el.getAttribute('name');
            if (nameAttr) {
                el.setAttribute('name', nameAttr.replace('INDEX', newIndex));
            }

            let baseName = '';
            let isErrorSpan = el.classList.contains('error-span');
            let fieldStub = el.dataset.fieldStub; // For error spans

            if (el.tagName.toLowerCase() === 'input' || el.tagName.toLowerCase() === 'select') {
                baseName = el.getAttribute('name').match(/items\[\d+\]\.(.+)$/)[1]; // Extract field name (name, balance, clientId)
            } else if (el.tagName.toLowerCase() === 'label') {
                // Find the corresponding input/select based on the *newly* generated structure or a data attribute
                const forInput = templateContent.querySelector(`[name$=".${el.textContent.replace(':', '').trim().toLowerCase()}"]`); // Simple guess based on label text
                if (forInput && forInput.getAttribute('name')) {
                    baseName = forInput.getAttribute('name').match(/items\[\d+\]\.(.+)$/)[1];
                }
            } else if (isErrorSpan && fieldStub) {
                baseName = fieldStub;
            }


            if (baseName) {
                const newId = baseName + newIndex;
                el.setAttribute('id', newId + (isErrorSpan ? '-error' : '')); // Unique ID, suffix for error span

                if (el.tagName.toLowerCase() === 'label') {
                    el.setAttribute('for', newId); // Link label to input/select
                }
            }


            // Clear values
            if (el.tagName.toLowerCase() === 'input') {
                el.value = '';
                if (el.type === 'number') el.value = ''; // Explicitly clear number
            } else if (el.tagName.toLowerCase() === 'select') {
                el.selectedIndex = 0; // Reset to "Select Client"
            } else if (isErrorSpan) {
                el.textContent = ''; // Clear any previous error text in the template clone
            }
        });

        container.appendChild(templateContent);
        updateRemoveButtonVisibility();
    });

    // --- Function remove form ---
    function removeAccountForm(button) {
        const sections = container.querySelectorAll('.account-form-section');
        if (sections.length > 1) { // Keep at least one form
            button.closest('.account-form-section').remove();
            reindexForms();
            updateRemoveButtonVisibility();
        } else {
            alert("You must keep at least one account form.");
        }
    }

    // --- Function reindex forms ---
    function reindexForms() {
        const sections = container.querySelectorAll('.account-form-section');
        accountIndex = sections.length; // Reset global index count

        sections.forEach((section, newIndex) => {
            // Update section ID
            section.id = 'account-section-' + newIndex;

            // Update title (handle initial forms without span correctly)
            const h5 = section.querySelector('h5');
            if (h5) {
                const h5Span = h5.querySelector('span');
                if (h5Span) {
                    h5Span.textContent = (newIndex + 1);
                } else {
                    h5.textContent = `Account #${newIndex + 1}`; // For initial static forms
                }
            }


            section.querySelectorAll('input, select, label, span[th\\:errors], span.error-span').forEach(el => { // Include spans with th:errors
                // Update name attribute
                const nameAttr = el.getAttribute('name');
                if (nameAttr) {
                    el.setAttribute('name', nameAttr.replace(/\[\d+\]/, `[${newIndex}]`));
                }
                // Update th:field attribute if present (less common to update dynamically, but good practice)
                const fieldAttr = el.getAttribute('th:field');
                if (fieldAttr) {
                    el.setAttribute('th:field', fieldAttr.replace(/\[\d+\]/, `[${newIndex}]`));
                }


                // Update IDs and 'for' attributes
                let baseName = '';
                let currentId = el.getAttribute('id'); // Get current ID
                let isErrorSpan = el.classList.contains('text-danger'); // Broader check for error spans
                let isThErrorSpan = el.hasAttribute('th:errors');

                // Extract base name (name, balance, clientId)
                if (el.tagName.toLowerCase() === 'input' || el.tagName.toLowerCase() === 'select') {
                    // Try from name first
                    if(nameAttr) baseName = nameAttr.match(/items\[\d+\]\.(.+)$/)?.[1];
                    // Fallback to ID if name didn't match (e.g., initial render)
                    if(!baseName && currentId) baseName = currentId.replace(/\d+$/, '');

                } else if (el.tagName.toLowerCase() === 'label') {
                    let currentFor = el.getAttribute('for');
                    if(currentFor) baseName = currentFor.replace(/\d+$/, '');
                } else if (isErrorSpan && currentId) {
                    // Guess base name from error span ID if possible
                    baseName = currentId.replace(/-error$/, '').replace(/\d+$/, '');
                }

                if (baseName) {
                    const newId = baseName + newIndex;
                    if (isErrorSpan || isThErrorSpan) {
                        el.setAttribute('id', newId + '-error'); // Add suffix for clarity
                    } else {
                        el.setAttribute('id', newId);
                    }

                    if (el.tagName.toLowerCase() === 'label') {
                        el.setAttribute('for', newId); // Update label's 'for'
                    }
                }
            });
        });
    }

    // --- Function update remove button visibility ---
    function updateRemoveButtonVisibility() {
        const sections = container.querySelectorAll('.account-form-section');
        sections.forEach((section, index) => {
            const removeBtn = section.querySelector('.remove-account-btn');
            if (removeBtn) {
                removeBtn.style.display = sections.length > 1 ? '' : 'none';
            }
        });
    }

    // Initial setup on page load
    document.addEventListener('DOMContentLoaded', () => {
        reindexForms(); // Ensure initial forms are correctly indexed
        updateRemoveButtonVisibility();
    });

    /*]]>*/
</script>

</body>
</html>